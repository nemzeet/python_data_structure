# 정렬 (Sorting, 알고리즘)

### 정의
> 데이터를 순서대로 나열하기 위한 절차적인 과정
> 
> 종류 : 선택, 삽입, 버블 퀵, ...

<br/>

### 알고리즘의 성능 분석
> 1. 정확성 : 올바른 자료가 입력되었을 때 유한한 시간 내에 올바른 결과를 도출하는가
> 2. 명확성 : 알고리즘이 이해하기 쉽고 명확하게 작성되었는가
> 3. 수행량 : 알고리즘의 주요 연산이 얼마나 반복되는가
> 4. 메모리 사용량 : 문제를 해결하기 위해 얼마나 많은 메모리 공간을 필요로 하는가
> 5. 최적성 : 알고리즘이 문제 해결 조건에 최적으로 부합하는가


<br/>

### 성능 분석 방법
> #### 1. 공간 복잡도 (Space Complexity)
>> 알고리즘을 프로그램으로 실행하여 완료하는데 필요한 총 저장 공간
> 
> #### 2. 시간 복잡도 (Time Complexity)
>> 알고리즘을 프로그램으로 실행하여 완료하기 까지의 총 소요시간
>> 
>> (컴퓨터 프로그램의 입력 값과 연산 수행시간의 상관관계를 나타낸 척도)
>> 
>> 빅오표기법을 사용해서 표기 (반복문의 횟수)

<br/>
<br/>

-----

### 선택 정렬
> 최솟값 또는 최대값을 선택하여 가장 앞에다가 위치하는 작업을 반복하여 정렬하는 방법
> 
> 시간복잡도 : O(n^2)
> 
> 장점 : 구현이 쉽다.
> 
> 단점 : 다른 정렬에 비해 시간이 오래걸린다.
> <br/>
> <br/>
> 
> #### 기본 로직 
> 1. 정렬되지 않은 인덱스의 맨 앞에서부터 이를 포함한다.
> 2. 최소값을 찾았으면 그 값을 현재 인덱스의 값과 바꿔준다.
> 3. 다음 인덱스로 이동하여 위의 과정을 반복한다.

<br/>

### 버블 정렬
> 인접한 두 수를 비교하여 큰 수를 뒤로 보내는 작업을 반복하여 정렬하는 방법 <br/>
> 시간복잡도 : O(n^2)
>
> 장점 : 구현이 쉽다. 코드가 직관적이다.
> 단점 : 시간이 오래걸린다.
> <br/>
> <br/>
> 
> #### 기본 로직
> 1. 맨 앞에서부터 바로 뒤에 있는 값과 비교 후, 순서가 거꾸로 되어있다면 둘의 위치를 바꾼다. <br/>
>   4 1 3 5 2 <br/>
>   1 4 3 5 2
>   
>   
> 2. 맨 마지막까지 반복해서 바꾸어 주었다면 가장 마지막에는 최대값이 위치해 있다. <br/>
>   1 3 4 2 [5] <br/>
>   
>   
> 3. 위의 과정을 반복하여 하되, 이전보다 한번 덜 바꾸면 그 다음 최대값이 바로 앞에 위치할 것이다.

<br/>

### 삽입 정렬
> 현재 위치에서 그 앞의 인덱스들 중에 자신이 들어갈 위치를 찾아서 그 위치에 삽입하여 정렬하는 방법 <br/>
> 시간복잡도 : O(n) ~ O(n^2)
>  
>  장점 : 구현이 쉽다. 코드가 직관적이다.
>  단점 : 시간이 오래걸린다.
>  <br/>
>  <br/>
>  
>  ### 기본 로직
> 1. 현재 인덱스 (i)의 값을 임시저장한다 (tmp) <br/>
> 2. 그 앞의 값들과 비교하였을 때 값이 더 크면 뒤에 덮어씌워준다. <br/>
> 3. 작은 값을 찾는 순간의 idx위치+1 에 임시 저장했던 tmp를 덮어씌워준다. <br/>
> 4. i를 하나 증가시키며 위의 과정 반복

<br/>

### 퀵정렬
> 분할 정복(Divide and Conquer)방식으로 정렬을 수행하는 방법 <br/>
> 시간복잡도 : O(nlog(n))
> 
> 장점 : 알고리즘 중 가장 빠른 평균 시간을 갖는다. <br/>
> 단점 : 구현이 복잡하다.
> <br/>
> <br/>
> 
> ### 기본 로직
> 1. 리스트 안에서 가장 오른쪽 요소를 pivot으로 선택 <br/>
> 2. 리스트에서 오른쪽 두번째 요소까지 반복을 돌면서 pivot과 비교 <br/>
> 3. 만약 요소의 크기가 pivot보다 자거나 같다면 idx를 하나 증가시키며 그 위치의 요소와 스왑한다. <br/>
> 4. 2번의 반복이 끝났다면, 가장 오른쪽 요소를 idx하나 증가시킨 후 그 위치와 스왑 <br/>
> 5. 방금 스왑된 그 idx+1 위치를 리턴 <br/>
> 6. 1~5 까지의 과정을 거쳤다면 리턴된 그 위치 왼쪽에는 그 위치의 요소보다 작은 값들만, 오른쪽에는 큰 값들만 모여있다. <br/>
> (리턴된 위치의 값은 정상적으로 정렬된 값이다.) <br/>
> 7. 정렬된 위치의 값을 제외하고 왼쪽, 오른쪽 리스트들을 분할하여 quickSort()재귀호출을 해준다. <br/>
> 8. 분할된 리스트의 크기가 1이 되었다면 left == q-1, 혹은 right == q+1 이므로 재귀호출을 멈춘다. <br/>

<br/>

### 분할 정복
> 문제를 작은 2개로 분리하고 각각 해결 후 모아서 원래의 문제를 해결하는 



